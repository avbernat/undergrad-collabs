library(reticulate)
knitr::opts_chunk$set(echo = TRUE)
combos
# generic models combinatorics
library(stringr)
`%notin%` = Negate(`%in%`)
setwd("~/Desktop/")
source_python("combinatorics.py")
library(reticulate)
source_python("~/Desktop/combinatorics.py")
library(reticulate)
source_python("~/Desktop/combinatorics.py")
combos
for(c in combos) {
print(combos)
}
library(reticulate)
source_python("~/Desktop/combinatorics.py")
generate_combinations(c("A","B","C"))
generate_combinations(c("A","B"))
generate_combinations(c("A","B"))
generate_combinations(c("A","C"))
generate_combinations(c("A","B", "C", "D"))
generate_combinations(list("A","B", "C", "D"))
generate_combinations(list("A","B", "C"))
generate_combinations(c("A","B", "C"))
generate_combinations(c("A","B", "C"))
source_python("~/Desktop/combinatorics.py")
generate_combinations(c("A","B", "C"))
generate_combinations(c("A","B"))
source_python("~/Desktop/combinatorics.py")
generate_combinations(c("A","B"))
generate_combinations(c("A","B", "C", "D"))
source_python("~/Desktop/combinatorics.py")
generate_combinations(c("A","B", "C", "D"))
library(reticulate)
# This doesn't work fully still: ['1', 'B', 'A', 'A + B']
source_python("~/Desktop/combinatorics.py")
generate_combinations(c("A","B", "C"))
combos
generate_combinations(c("A","B", "C"))
combos = generate_combinations(c("A","B", "C"))
combos
for(c in combos) {
print(combos)
}
combos
combos[1]
combos
combos = generate_combinations(c("A","B", "C"))
combos
for(c in combos) {
print(combos)
}
m0<-glm(R~1, family=binomial, data=data)
for(c in combos) {
print(combos)
}
A = [1,3,4]
A = c(1,3,4)
B = c(5,6,7)
C = c(7,8,9)
get("C")
R = c(1,1,1)
data= data.frame(R,A,B,C)
data
glm(get("R") ~ get("C"), family = binomial, data=data)
glm(R ~ C, family = binomial, data=data)
glm(get("R") ~ get("C * B"), family = binomial, data=data)
glm(get("R") ~ get("C"), family = binomial, data=data)
for(c in combos) {
print(combos)
}
models = list()
i = 0
for(c in combos) {
i = i + 1
# need to do string splitting to make this work and apply the get() function to each var
if (c == 1){
m = glm(R~1, family=binomial, data=data)
models[[i]] = m
}
if (length(c) == 1) {
m = glm(R~get(c), family=binomial, data=data)
models[[i]] = m
}
}
models = list()
i = 0
for(c in combos) {
i = i + 1
# need to do string splitting to make this work and apply the get() function to each var
if (c == "1"){
m = glm(R~1, family=binomial, data=data)
models[[i]] = m
}
if (length(c) == 1) {
m = glm(R~get(c), family=binomial, data=data)
models[[i]] = m
}
}
combos
combos[[1]]
models = list()
i = 0
for(c in combos) {
print(c)
i = i + 1
# need to do string splitting to make this work and apply the get() function to each var
if (c == "1"){
m = glm(R~1, family=binomial, data=data)
models[[i]] = m
}
if (length(c) == 1) {
m = glm(R~get(c), family=binomial, data=data)
models[[i]] = m
}
}
combos[[1]]
class(combos[[1]])
class(combos[[1]] == "1")
combos[[1]] == "1"
models = list()
i = 0
for(c in combos) {
print(c)
i = i + 1
# need to do string splitting to make this work and apply the get() function to each var
if (combos[[i]] == "1"){
m = glm(R~1, family=binomial, data=data)
models[[i]] = m
}
if (length(c) == 1) {
m = glm(R~get(c), family=binomial, data=data)
models[[i]] = m
}
}
length(c)
i = 0
for(c in combos) {
print(c)
i = i + 1
# need to do string splitting to make this work and apply the get() function to each var
if (combos[[i]] == "1"){
m = glm(R~1, family=binomial, data=data)
models[[i]] = m
}
if (length(c) == 1 & != "1") {
m = glm(R~get(c), family=binomial, data=data)
models[[i]] = m
}
}
models = list()
i = 0
for(c in combos) {
print(c)
i = i + 1
# need to do string splitting to make this work and apply the get() function to each var
if (c == "1"){
m = glm(R~1, family=binomial, data=data)
models[[i]] = m
}
if (length(c) == 1 & c != "1") {
m = glm(R~get(c), family=binomial, data=data)
models[[i]] = m
}
}
models
models[[1]]
models[[2]]
models[[3]]
models[[2]]
models[[3]]
models[[4]]
models
combos[[5]]
combos[[6]]
strsplit(combos[[6]], " ")
get("+")
glm(get("R") ~ c(get("C"), get("+"), get("A")), family = binomial, data=data)
get("+")
get("A+C")
mget("A + C")
if + then:
m = glm(R~get(c) + get("A"), family=binomial, data=data)
m = glm(R~get(c) + get("A"), family=binomial, data=data)
m = glm(R~get(B) + get("A"), family=binomial, data=data)
m = glm(R~get("B") + get("A"), family=binomial, data=data)
m
m = glm(R~get("B") get("+") get("A"), family=binomial, data=data)
c =
#if + then:
m = glm(R~get("B") + get("A"), family=binomial, data=data)
m
c =
#if + then:
get("+")
c =
#if + then:
get("+")
get("+")
#c =
#if + then:
mget(c("A", "+", "B"))
#c =
#if + then:
mget(c)
c
c = "A + C"
mget(c)
d  = get("A") + get("C")
d
d  = get("A") + get("B")
glm(R~d, family=binomial, data=data)
models
library(reticulate)
# This doesn't work fully still: ['1', 'B', 'A', 'A + B']
# missing A*B
source_python("~/Desktop/combinatorics.py")
combos = generate_combinations(c("A","B", "C"))
combos
R = c(1,1,1)
A = c(1,3,4)
B = c(5,6,7)
C = c(7,8,9)
data= data.frame(R,A,B,C)
models = list()
i = 0
for(c in combos) {
print(c)
i = i + 1
# need to do string splitting to make this work and apply the get() function to each var
if (c == "1"){
m = glm(R~1, family=binomial, data=data)
models[[i]] = m
}
if (length(c) == 1 & c != "1") {
m = glm(R~get(c), family=binomial, data=data)
models[[i]] = m
}
else {
}
}
